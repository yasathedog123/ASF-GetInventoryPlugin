# SteamTokenDumperPlugin

`SteamTokenDumperPlugin` is official ASF **[plugin](https://github.com/JustArchiNET/ArchiSteamFarm/wiki/Plugins)** developed by us, which allows you to contribute to **[SteamDB](https://steamdb.info)** project by sharing package tokens, app tokens and depot keys that your Steam account has access to. Подробную информацию о собираемых данных, и о том почему SteamDB нуждается в них вы можете найти на странице **[Token Dumper](https://steamdb.info/tokendumper)** в SteamDB. Передаваемые данные не включают в себя никакой потенциально конфиденциальной информации, и не представляют риска для безопасности/приватности, как указано в описании выше.

---

## Активация плагина

ASF уже включает в себя плагин `SteamTokenDumperPlugin`, однако сам плагин по умолчанию отключен. Вы можете включить плагин, установив параметр `SteamTokenDumperPluginEnabled` в глобальной конфигурации ASF равным `true`, в соответствии с форматом JSON:

```json
{
  "SteamTokenDumperPluginEnabled": true
}
```

При запуске ASF плагин сообщит что он был успешно включен через стандартный механизм журналирования ASF. Вы также можете включить плагин через наш cетевой генератор конфигураций.

---

## Технические подробности

После активации, плагин будет использовать ботов, запущенных в вашем ASF, для сбора информации в виде токенов пакетов, токенов приложений и ключей хранилища к которым ваши боты имеют доступ. Модуль сбора информации включает в себя пассивные и активные процедуры, которые должны минимизировать дополнительную нагрузку, вызванную сбором данных.

Для выполнения поставленных задач, в дополнение к процедурам сбора информации, описанным выше, также инициализируется процедура передачи информации, ответственная за определение того, какие именно данные следует передавать в SteamDB на периодическом основании. Эта процедура будет запускаться примерно через `1` после запуска ASF, а затем будет повторяться каждые `24` часа. Плагин будет делать всё возможное, чтобы минимизировать количество данных, которые необходимо передать, поэтому возможно что часть данных, собранных плагином, будет оценена как бесполезная к передаче, и потому проигнорирована (например, обновление приложения, которое не меняет токен доступа).

Плагин использует базу данных постоянного хранения, расположенную в файле `config/SteamTokenDumper.cache`, она выполняет роль, аналогичную `config/ASF.db` в ASF. Этот файл используется чтобы записывать собранную и переданную информацию, и минимизировать количество работы, которую необходимо выполнить в разных запусках ASF. Удаление этого файла приведёт к тому, что процесс запускается с самого начала, чего по возможности следует избегать.

---

## Данные

ASF включает в запрос `steamID` участника, который определяется как `SteamOwnerID`, который вы установили в ASF, либо, если его нет, то как идентификатор Steam бота, у которого больше всего лицензий. Указанный участник может получить дополнительные привилегии от SteamDB за помощь в работе (как например, статус "donator" на сайте), но это остаётся полностью на усмотрение SteamDB.

В любом случае, администрация SteamDB заранее благодарит вас за вашу помощь. Переданные данные позволяют SteamDB работать, в частности, отслеживать информацию о пакетах, приложениях и хранилищах, что было бы невозможно без вашей помощи.

---

## Команда

STD plugin comes with an extra ASF command, `std [Bots]`, which allows you to trigger refresh and submission for selected bots on demand. Using the command doesn't require enabled config, which allows you to skip automatic gathering and submission, and control the process yourself manually. Naturally it can also be executed with enabled config, which will simply trigger the usual gathering and submission procedures earlier than expected.

We recommend `!std ASF` in order to trigger refresh for all available bots. However, you can also trigger it for selected ones if you'd like to.

---

## Расширенная конфигурация

Our plugin supports advanced config which might come useful for people that would like to tweak the internals to their preference.

Расширенная конфигурация имеет следующую структуру, расположенную в `ASF.json`:

```json
{
  "SteamTokenDumperPlugin": {
    "Enabled": false,
    "SecretAppIDs": [],
    "SecretDepotIDs": [],
    "SecretPackageIDs": [],
    "SkipAutoGrantPackages": true
  }
}
```

Все параметры описаны ниже:

### `Enabled`

Параметр типа `bool` со значением по-умолчанию `false`. Это свойство действует так же, как `SteamTokenDumperPluginEnabled` свойство корневого уровня, описанное выше, и может быть использовано вместо него, специально для тех, кто предпочитает иметь весь конфиг, связанный с плагином, в собственной структуре (скорее всего, это те, кто уже использует другие расширенные свойства, описанные ниже).

---

### `SecretAppIDs`

Параметр типа `ImmutableHashSet<uint>` с пустым значением по-умолчанию. Это свойство указывает `appID`, которые плагин не разрешит, и, если они уже разрешены, не будет отправлять токен для. Это свойство может быть полезно для людей, имеющих доступ к потенциально конфиденциальной информации о неопубликованных элементах, особенно для разработчиков, издателей или участников закрытого бета-тестирования.

---

### `SecretDepotIDs`

Параметр типа `ImmutableHashSet<uint>` с пустым значением по-умолчанию. Это свойство определяет `depotIDs`, которые плагин не будет разрешать, а если они уже разрешены, то не будет отправлять ключ для них. Это свойство может быть полезно для людей, имеющих доступ к потенциально конфиденциальной информации о неопубликованных элементах, особенно для разработчиков, издателей или участников закрытого бета-тестирования.

---

### `SecretPackageIDs`

Параметр типа `ImmutableHashSet<uint>` с пустым значением по-умолчанию. Это свойство определяет `packageIDs` (также известные как `subIDs`), которые плагин не будет разрешать, а если они уже разрешены, то не будет передавать токен для них. Это свойство может быть полезно для людей, имеющих доступ к потенциально конфиденциальной информации о неопубликованных элементах, особенно для разработчиков, издателей или участников закрытого бета-тестирования.

---

### `SkipAutoGrantPackages`

Параметр типа `bool` со значением по-умолчанию `true`. Это свойство действует очень похоже на `SecretPackageIDs` и при включении будет вызывать пропуск пакетов с `EPaymentMethod` из `AutoGrant` во время процедуры разрешения, описанной ниже. Метод оплаты `AutoGrant` используется **[Steamworks](https://partner.steamgames.com)** для автоматического предоставления пакетов в учетные записи разработчиков. Хотя это не так явно, как другие параметры `Secret`, и поэтому ничего не гарантирует (поскольку у вас могут быть другие пакеты, кроме `AutoGrant`, которые вы по-прежнему не хотите отправлять), этого должно быть достаточно для пропуска большинства, если не всех секретных пакетов. Эта опция включена по умолчанию, так как люди, которые имеют доступ к пакетам `AutoGrant`, почти никогда не захотят утечек данных в широкие массы, и поэтому использование значения `false` очень ситуативно.

---

## Дальнейшее объяснение

На корневом уровне каждая учетная запись Steam владеет набором пакетов (лицензий, подписок), которые классифицируются по их `packageID` (также известный как `subID`). Каждый пакет может содержать несколько приложений, классифицированных по их `appID`. Каждое приложение может включать несколько хранилищ, классифицированных по их `depotID`.

```text
├── sub/124923
│     ├── app/292030
│     │     ├── depot/292031
│     │     ├── depot/378648
│     │     └── ...
│     ├── app/378649
│     └── ...
└── ...
```

Наш плагин включает две процедуры, которые учитывают пропущенные элементы - процедуру разрешения и процедуру отправки.

Процедура разрешения отвечает за разрешение дерева, которое вы видите выше. Предварительно занеся пакеты/приложения/хранилища в черный список, вы эффективно вырежете дерево вместо ветки/листа, занесенных в черный список, без дополнительной необходимости указывать оставшиеся его части. В нашем примере выше, если пакет `124923` был проигнорирован, будь то `SecretPackageID` или `SkipAutoGrantPackages`, и это был единственный принадлежащий вам пакет, связанный с `292030` appID, то appID `292030` также не будет разрешен, и по определению, если не будет других разрешенных приложений, связанных с хранилищами `292031` и `378648`, то они также не будут разрешены. Однако имейте в виду, что если плагин уже разрешил дерево, то фактически это остановит только обновление данного элемента (например, добавление новых приложений), это не заставит плагин «забыть» о существующих элементах, которые уже были разрешены (например, приложения, найденные в этом пакете до того, как вы решили его занести в черный список). Если вы только что включили некоторые опции пропуска, и хотели бы убедиться, что ASF не переходит к уже решенному дереву, вы можете удалить `config/SteamTokenDumper.cache` файл, где плагин хранит свой кэш.

Процедура отправки отвечает за отправку токенов пакетов, токенов приложений и ключей хранилища уже решенных элементов (с помощью процедуры разрешения выше). Здесь ваш черный список имеет немедленный эффект, так как даже если плагин уже разрешил информацию, процедура отправки фактически не отправит ее в SteamDB, если она у вас в черном списке, независимо от того, была она разрешена или нет. Однако имейте в виду, что мы больше не говорим о дереве на данный момент, процедура отправки не знает, исходит ли информация о приложении из того или иного пакета, поэтому она пропускает информацию только об определенных элементах, внесенных в черный список, независимо от отношения, в которых они находятся с другими.

Для большинства разработчиков и издателей достаточно включить `SkipAutoGrantPackages`, потенциально наделённый только `SecretPackageIDs`, поскольку это эффективно сокращает начальную ветку дерева и гарантирует, что включенные в него приложения и репозитории не будут передаваться до тех пор, пока нет никаких других пакетов, связанных с этим приложением. Если вы хотите быть уверенным вдвойне, в дополнение к этому вы также можете использовать `SecretAppIDs`, который пропустит разрешение приложения, даже если есть другие лицензии, которые вы не занесли в черный список, связанные с ним. Использование `SecretDepotIDs` не требуется, если только у вас нет особой конкретной потребности (например, пропустить только конкретное хранилище при отправке информации о пакетах и приложениях) или если вы хотите добавить еще один уровень, будьте в безопасности втрое.